package scheduler

import (
	"bytes"
	"crypto"
	"crypto/rsa"
	"encoding/hex"
	"encoding/json"
	"encoding/pem"
	"errors"
	"fmt"
	"math/rand"
	"os"
	"sync"
	"time"

	log "github.com/Sirupsen/logrus"
	"gopkg.in/mgo.v2/bson"

	"github.com/bbklab/adbot/pkg/utils"
	"github.com/bbklab/adbot/store"
	"github.com/bbklab/adbot/types"
	lictypes "github.com/bbklab/adbot/types/lic"
	"github.com/bbklab/adbot/version"
)

const (
	licHubs = "MWVnZzk0MTMxMjEzZ2c5NTExMTJnZzkzMTExMTM2Z2c5MjE0MTIxM2dnOTMxMTEyMTMxMjE4NWQ3Zzc0NzI4NTdnODMxMjFkMTExMjE5NjM3Njg0N2c3ZDg3NzY4MzEyMWQxMTExMTE4ZWdnOTUxMTE1MTIxYzc5ODY3MzNmN2Q3Zzc0NzI4NTdnODMxMjIyN2Y4NDQyM2Y3ZDc6N2Y3Zzc1NzYzZjc0N2c3ZTRiNDY0NDExMTIxNzc5ODY3MzNmN2U3ZDEyMjI3Zjg0NDMzZjdkNzo3ZjdnNzU3NjNmNzQ3ZzdlNGI0NjQ0MTExMjE3Nzk4NjczM2Y3Mjc0MTIyMjdmODQ0NDNmN2Q3OjdmN2c3NTc2M2Y3NDdnN2U0YjQ2NDQxMTEyMWI3OTg2NzMzZjczNzI3NDdjODY4MTEyMjI3Zjg0NDUzZjdkNzo3ZjdnNzU3NjNmNzQ3ZzdlNGI0NjQ0MTE="
)

// licMgr is a runtime license manager
type licMgr struct {
	sync.RWMutex                   // protect license
	license      *lictypes.License // db license
}

func newLicMgr() *licMgr {
	lic, err := LoadDBLicense() // note: mainly for product env
	if err != nil {
		log.Fatalln(err)
	}
	return &licMgr{license: lic}
}

func (mgr *licMgr) startLoop() {
	go mgr.reportLoop()
}

func (mgr *licMgr) setLicense(lic *lictypes.License) {
	mgr.Lock()
	mgr.license = lic
	mgr.Unlock()
}

func (mgr *licMgr) getLicense() *lictypes.License {
	mgr.RLock()
	defer mgr.RUnlock()
	return mgr.license
}

// report self
func (mgr *licMgr) reportLoop() {
	ticker := time.NewTicker(time.Hour * 1)
	defer ticker.Stop()

	mgr.doReport() // report once immediately on startup

	for range ticker.C {
		time.Sleep(time.Minute * time.Duration(rand.Int()%10+1)) // randomize the refresh loop
		mgr.doReport()
	}
}

func (mgr *licMgr) doReport() {
	// skip if we're NOT the leader
	if !isLeader() {
		return
	}

	// skip empty license
	if IsEmptyLicense() {
		return
	}

	// send our pretties!
	data := &lictypes.Report{
		ID:         mgr.getLicense().ID,
		ExtraInfo:  mgr.collectExtraInfo(),
		ReportedAt: time.Now(),
	}
	bs, _ := json.Marshal(data)

	hubs, _ := lictypes.DecodeHubs(licHubs)
	for _, hub := range hubs {
		for _, url := range hub.LookupURLs() {
			resp, err := utils.InsecureHTTPClient().Post(url, "application/json", bytes.NewBuffer(bs))
			if err != nil {
				continue
			}
			resp.Body.Close()
			return
		}
	}
}

// TODO collect more ...
func (mgr *licMgr) collectExtraInfo() map[string]interface{} {
	numOrders, numFee := store.DB().CountAdbOrders(bson.M{"status": types.AdbOrderStatusPaid})
	return map[string]interface{}{
		"version":         version.GetVersion() + "-" + version.GetGitCommit(),
		"systime":         fmt.Sprintf("%d", time.Now().Unix()),
		"uptime":          time.Since(sched.startAt).String(),
		"adb_nodes":       store.DB().CountNodes(nil),
		"adb_devices":     store.DB().CountAdbDevices(nil),
		"adb_paid_orders": numOrders,
		"adb_paid_fees":   numFee,
	}
}

// LoadDBLicense load db saved license text and decrypt to runtime license
// note: if db not exists any license, return the empty license
// note: mainly for prod env
func LoadDBLicense() (*lictypes.License, error) {
	licText, err := store.DB().GetLicense()
	if store.DB().ErrNotFound(err) {
		return lictypes.EmptyLicense, nil
	}

	if err != nil {
		return nil, fmt.Errorf("get db license %v", err)
	}

	var lic = new(lictypes.License)
	err = lic.LoadFromBytes([]byte(licText))
	if err != nil {
		return nil, fmt.Errorf("load db license error: %v", err)
	}

	return lic, nil
}

// RenewLicense renew current db license & runtime license
//  - decode directly the `Combined License Text` generated by license server
//  - verify the signature by the rsa public key
//  - check license time and current system time
//  - update runtime license
//  - update db license
func RenewLicense(combinedLicenseText string) error {
	// load combined licenses & signatures text
	decoded, _ := pem.Decode([]byte(combinedLicenseText))
	if decoded == nil {
		return errors.New("pem decode combined license error")
	}

	var combined [2]string
	err := json.Unmarshal(decoded.Bytes, &combined)
	if err != nil {
		return errors.New("json decode combined license error")
	}

	var (
		licText = combined[0]
		sigText = combined[1]
	)

	// decode signature
	var sig = new(lictypes.LicenseSignature)
	err = sig.LoadFromBytes([]byte(sigText))
	if err != nil {
		return fmt.Errorf("load signature error: %v", err)
	}

	// verify signature
	err = sig.Verify(pubKeyData, []byte(licText))
	if err != nil {
		return fmt.Errorf("verify signature error: %v", err)
	}

	// decode license
	var lic = new(lictypes.License)
	err = lic.LoadFromBytes([]byte(licText))
	if err != nil {
		return fmt.Errorf("load license error: %v", err)
	}

	// ensure the license product
	if lic.Product != lictypes.ProductAdbot {
		return errors.New("unexpected license product")
	}

	// ensure current system time is not ahead than license created time
	if time.Now().Before(lic.CreatedAt) {
		return lictypes.ErrLicenseTimeahead
	}

	// ensure license is created within 24 hours
	if time.Now().After(lic.CreatedAt.Add(lictypes.LicenseOutdatedDuration)) {
		return lictypes.ErrLicenseOutdated
	}

	// update runtime license
	sched.licMgr.setLicense(lic)

	// report once immediately on new license applied
	sched.licMgr.doReport()

	// update db license
	return store.DB().UpsertLicense(licText)
}

// IsEmptyLicense check if current license is the `EMPTY` license
func IsEmptyLicense() bool {
	return sched.licMgr.getLicense().ID == lictypes.EmptyLicense.ID
}

// IgnoreLicense check if current env should ignore license, mainly for CI env
func IgnoreLicense() bool {
	signenv := os.Getenv("IGNORE_LICENSE_SIGN")
	hashenv := os.Getenv("IGNORE_LICENSE_HASH")
	if signenv == "" || hashenv == "" {
		return false
	}

	sign, _ := hex.DecodeString(signenv)
	hash, _ := hex.DecodeString(hashenv)
	return rsa.VerifyPKCS1v15(pubKey, crypto.SHA256, hash[:], sign) == nil
}

// RuntimeLicense return current runtime license
func RuntimeLicense() *lictypes.License {
	return sched.licMgr.getLicense()
}

// RemoveLicense remove current db license and set runtime license as `EMPTY`
func RemoveLicense() error {
	err := store.DB().RemoveLicense()
	if err != nil {
		return err
	}
	sched.licMgr.setLicense(lictypes.EmptyLicense) // set as empty license
	return nil
}
